\chapter{Various}

\section{Intervals}
    \Algorithm{IntervalContainer.h}
    {}{}
    {cpp}{code/various/IntervalContainer.h}
    {kactl}
    \Algorithm{IntervalCover.h}
    {}{}
    {cpp}{code/various/IntervalCover.h}
    {kactl}

\section{Misc. algorithms}
    \Algorithm{FastKnapsack.h}
    {}{}
    {cpp}{code/various/FastKnapsack.h}
    {kactl}

\section{Dynamic programming}
    \Algorithm{KnuthDP.h}
    {}{}
    {cpp}{code/various/KnuthDP.h}
    {kactl}

\section{Optimization tricks}
	\subsection{Bit hacks}
		\begin{itemize}
			\item \verb@x & -x@ is the least bit in \texttt{x}.
			\item \verb@for (int x = m; x; ) { --x &= m; ... }@ loops over all subset masks of \texttt{m} (except \texttt{m} itself).
			\item \verb@c = x&-x, r = x+c; (((r^x) >> 2)/c) | r@ is the next number after \texttt{x} with the same number of bits set.
		\end{itemize}
	\subsection{Pragmas}
		\begin{itemize}
			\item \lstinline{#pragma GCC optimize ("Ofast")} will make GCC auto-vectorize loops and optimizes floating points better.
			\item \lstinline{#pragma GCC target ("avx2")} can double performance of vectorized code, but causes crashes on old machines.
			\item \lstinline{#pragma GCC optimize ("trapv")} kills the program on integer overflows (but is really slow).
		\end{itemize}
    \Algorithm{FastMod.h}
    {}{}
    {cpp}{code/various/FastMod.h}
    {kactl}
    \Algorithm{FastInput.h}
    {}{}
    {cpp}{code/various/FastInput.h}
    {kactl}
    \Algorithm{SIMD.h}
    {}{}
    {cpp}{code/various/SIMD.h}
    {kactl}
