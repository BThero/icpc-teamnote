\begin{itemize}[noitemsep]
    \item (예비소집) bits/stdc++.h, int128, long double 80bit, avx2 확인
    \item (예비소집) 스택 메모리(지역 변수, 재귀, 람다 재귀), 제출 파일 크기 확인
    \item (예비소집) MLE(힙,스택), stderr 출력 RTE?, 줄 앞뒤 공백 채점 결과
    \item 비슷한 문제를 풀어본 적이 있는가?
    \item 단순한 방법에서 시작할 수 있을까? (Brute Force)
    \item 내가 문제를 푸는 과정을 수식화할 수 있을까? (예제를 직접 해결하면서)
    \item 문제를 단순화할 수 없을까? / 그림으로 그려볼 수 있을까?
    \item 수식으로 표현할 수 있을까? / 문제를 분해할 수 있을까?
    \item 뒤에서부터 생각해서 풀 수 있을까? / 순서를 강제할 수 있을까?
    \item 특정 형태의 답만을 고려할 수 있을까? (정규화)
    \item 구간을 통째로 가져간다 : 플로우 + 적당한 자료구조\\$(i,i+1,k,0),(s,e,1,w),(N,T,k,0)$
    \item a = b : a만 이동, b만 이동, 두 개 동시에 이동, 반대로 이동
    \item 말도 안 되는 것 / 당연하다고 생각한 것 다시 생각해 보기
    \item Directed MST / Dominator Tree
    \item 일정 비율 충족 or 2~3개로 모두 커버 : 랜덤
    \item 확률 : DP, 이분 탐색(NYPC 2019 Finals C)
    \item 최대/최소 : 이분 탐색, 그리디(Prefix 고정, Exchange Argument), DP(순서 고정)
    \item 냅색: 파라미터 순서 변경, min plus convolution, FFT
    \item signal(SIGSEGV,[](int)\{\_Exit(0);\}); converts segfaults into WA. SIGABRT(assertion fail), SIGFPE(0div)
    \item feenableexcept(29) kills problem on NaNs(1), 0div(4), inf(8), denormals(16)
\end{itemize}